import { EventEmitter } from '@angular/core';
import { HelperService } from '../services/helper.service';
import { DeckCard } from './deckCard.model';

export class Deck {

  /**
   * The deck's unique id number. Used for saving it to the database.
   *
   * @private
   * @type {number}
   * @memberof Deck
   */
  private _id: number;
  public get id(): number { return this._id; }
  public set id(value: number) { this._id = value; }

  /**
   * The deck's user-given name.
   *
   * @private
   * @type {string}
   * @memberof Deck
   */
  private _name: string;
  public get name(): string { return this._name; }
  public set name(value: string) { this._name = value; }

  /**
   * An array of objects dynamically generated by the individual cards in
   * the deck. Keeps track of anything listed in the type property of an MTG.io
   * card.
   *
   * @private
   * @type {*}
   * @memberof Deck
   */
  private _typeTotals: any;
  public get typeTotals (): any { return this._typeTotals; }
  public set typeTotals (value: any) { this._typeTotals = value; }

  /**
   * The cards the user has chosen to be included in this deck.
   *
   * @private
   * @type {DeckCard[]}
   * @memberof Deck
   */
  private _cards: DeckCard[];
  public get cards(): DeckCard[] { return this._cards; }
  public set cards(value: DeckCard[]) { this._cards = value; }

  /**
   * Up to two cards can be a commander. If two cards are both commanders
   * than both cards must contain the keyword Partner in their text property.
   * Otherwise, only one commander per deck, and that commander must be a legendary
   * creature or a planeswalker specifically labeled to be a commander.
   *
   * @private
   * @type {DeckCard[]}
   * @memberof Deck
   */
  private _commander: DeckCard[];
  public get commander(): DeckCard[] { return this._commander; }
  public set commander(value: DeckCard[]) { this._commander = value; }

  /**
   * Lists out the type of deck this deck is: Commander, Legacy, or Vintage.
   *
   * @private
   * @type {string[]}
   * @memberof Deck
   */
  private _types: string[];
  public get types(): string[] { return this._types; }
  public set types(value: string[]) { this._types = value; }

  // TODO: create another property and implement its use that would govern the play style of the deck
  // (AKA: Singleton, 5-color, Pauper, Cube, custom, Standard, Modern, etc.)

  private _numberOfCards: number;
  public get numberOfCards(): number { return this._numberOfCards; }
  public set numberOfCards(value: number) { this._numberOfCards = value; }

  constructor () {
    this.id = Date.now() + Math.floor(Math.random() * 1000000) + 1;
    this.typeTotals = [];
    this.cards = [];
    this.commander = [];
    this.types = [];
    this.numberOfCards = this.calculateNumberOfCards();
  }

  /**
   * Dynamically keeps track of the amount of cards in the deck.
   *
   * @returns {number}
   * @memberof Deck
   */
  public calculateNumberOfCards (): number {
    let sum = 0;
    this.cards.forEach(card => sum += card.amount);
    return sum;
  }

  public addDeckType (type: string): string[] {
    this.types.push(type.toLowerCase());
    return this.types;
  }

  public removeDeckType (type: string): string[] {
    const loc = this.types.findIndex(element => element.toLowerCase() === type.toLowerCase());
    this.types.splice(loc, 1);
    return this.types;
  }
}
